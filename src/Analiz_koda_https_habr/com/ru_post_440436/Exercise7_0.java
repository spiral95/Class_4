package Analiz_koda_https_habr.com.ru_post_440436;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

public class Exercise7_0 {
    //Задача:
    //Постройте частотный словарь букв русского (или английского) алфавита. Опустим проблему выбора и анализа
    // корпуса языка, достаточно будет взять текст небольшой длины).

    static void buildDictionaryWithMap(String text){
        text = text.toLowerCase();
// объявляем пустой метод - buildDictionaryWithMap, который получает на вход строку - text.
// Данный метод при помощи стрингового метода toLowerCase() возвращает строку, содержащию копию данной (text),
// приведенную к нижнему регистру. Другими словами, метод создаёт копию переданной в него строки и присваивает переменной.
// Далеее работа метода продолжается...

        Map<Character, Integer> map = new HashMap<>();
// Создаём объект map. Запомнить синтаксис, так создаётся объект карты. (Интерфейс Map в нашем случае содержит
// два типа данных char(Character) и int(Integer) - используем классы-обёртки, т.к. не можем использовать примитивы.
// HashMap — основан на хэш-таблицах, реализует интерфейс Map (что подразумевает хранение данных в виде пар
// ключ/значение). Ключи и значения могут быть любых типов, в том числе и null.

        for(int i = 0; i < text.length(); i++){
            char ch = text.charAt(i);
// Запускаем цикл.
// Проходимся по длине скопированной строки - text и на каждой итерации возвращаем символ, находящийся в i-ой позиции.
// Присваиваем его переменной ch - она и есть ключ!
// Сравниваем данный символ со всеми символами от а до z

            if(ch >= 'a' && ch <= 'z'){
                map.compute(ch, (character, integer)
                        -> integer == null ? 1 : integer + 1);
// Если символ совпал, то применяем метод compute() к созданному объекту карты map.
// "Функциональный метод" - compute(key, (k,v)) принимает ключевой объект (ch) и лямбда-выражение в качестве параметров
// compute(key, (k,v)) -> (v == null) ? 1 : v + 1 // Запомни это написание.
// Здесь лямбда-выражение проверяет, является ли значение, сопоставленное данному ключу, нулевым или нет.

// Иными словами, если символ совпал с одной из букв, то запускается метод map.compute(), который проверяет,
// если эта буква (КЛЮЧ) В КАРТЕ имеет значение 0, то есть встречается первый раз, то ключу присваивается значение 1,
// если данная буква уже встречалась - то прибавляет к значению +1. И снова перезаписивает в HashMap.
            }
        }

        ArrayList<Map.Entry<Character, Integer>> entries =
                new ArrayList<>(map.entrySet());

// Создаём новый список entries, возвращающий все записи Map
// Map.Entry - это интерфейс, позволяющий работать с записями Map
// entrySet - это метод, который возвращает Set, который в свою очередь содержит все записи Map
// По просту, мы создаем список entries, который содержит все записи Map.

        entries.sort((o1, o2) -> Character.compare(o1.getKey(), o2.getKey()));

// Сортируем карту по ключам!!! К списку entries применяем метод sort, который производит сортировку при
// помощи лямбда выражения. Данное выражение свойственно интерфейсу Comparable, так как реализуется метод compare().

        for(Map.Entry<Character, Integer> entry : entries){
            System.out.println(entry.getKey() + " " + entry.getValue());

// проходимся по записям с помощью цикла foreach и выводим в консоль (ключ + значение)

        }
    }

    public static void main(String[] args) {
        buildDictionaryWithMap("buildDictionaryWithMap");
    }
}
